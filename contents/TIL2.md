---
date: '2021-07-27'
title: 'TIL02 | 첫 과제'
categories: ['TIL']
summary: '온보딩 코스를 진행하면서 첫 과제를 진행하게 되었다. 혼자 개발하는 방식이 아닌 페어 프로그래밍 방식으로 진행하였다.'
thumbnail: './images/TIL.png'
---

## 시작하기전

온보딩 코스를 진행하면서 첫 과제를 진행하게 되었다. 혼자 개발하는 방식이 아닌 페어 프로그래밍 방식으로 진행하였다. 기술 기능은 리스트 아이템을 서버에서 API를 받아와서 화면에 뿌려주고 인피니티 스크롤을 구현하는 과제 였다. 과제를 구현하기 전에 페어분이랑 어떻게 드라이버와 네비게이터를 나눌지 이야기를 하였고 기능별로 나눠서 하기로 하였다 그리고 폴더 구조를 미리 나눠놓고 시작을 하였다.

## UI 구현

먼저 UI 작업을 진행하였다. 뼈대를 잡고 안에 내용을 추가하는식으로 진행을 하였다. 리스트 아이템에 내용은 실제 데이터를 불러오기 전에 더미데이터를 만들어서 잘 화면에 나오는지 확인을 하였다. `style`은 `CSS in JS`방식으로 `emotion` 라이브러리를 사용했고 페어분과 이야기 한 후 나름 코딩컨벤션도 지키려고 최소한의 약속을 하고 스타일 작성할때 마음대로 작성하는 것이 아니라 나름 순서를 정한 후 지키며 작성하려고 노력하였다. (밖에서 부터 안쪽 흐름 [진유림님 블로그 참고](https://milooy.wordpress.com/2015/08/21/css-property-%EC%88%9C%EC%84%9C%EC%97%90-%EB%A7%9E%EC%B6%94%EC%96%B4-%EA%B9%94%EB%81%94%ED%9E%88-%EC%A0%81%EA%B8%B0/)) UI작업이 완료한 후 실제 데이터를 받아오기 위해 따로 폴더를 만들어서 관리를 하였다. 기능 구현이 많지 않아서 컴포넌트안에서 작성 할 수 있지만 실제 구현하는 것처럼 하기 위해 분리해서 작성하였다 분리 해서 작성해서 좋은 점은 재사용이 용이하기 때문이다. api컴포넌트를 만든 후 리스트 컴포넌트와 연결해서 데이터를 화면에 출력하는 것을 성공 하였다.

## InfinityScroll 구현

UI작업하고 데이터를 연결하는 것은 순조롭게 진행하게 되었다. 인피니티 스크롤은 페어분도 예전에 한번 만든 경험이 있고 나도 예저에 잠깐 만들어 본적이 있는데 제대로 만들어 보지 않아서 사실상 처음? 구현 하는 기능이였다.
구글링으로 검색하며 공부를 하였다 공부했던 내용을 짧게 정리해서 올려본다.

### 개념 **요약**

먼저 InfinityScroll를 구현하기 위해 두 가지 방법이 있었다. `onScrollEvnet` ,`IntersectionObserver`

첫번째로 `onScrollEvnet` 방식은 스크롤을 움직일때마다 이벤트가 계속 발생한다 때문에 메인스레드에 부담을 많이 주기때문에 성능최적화가 좋지 않는 단점이 있다.

두번째는 `IntersectionObserver` 방식은 관찰하고자 하는 타켓 요소가 viewport안에 들어올때와 나갈때만 반응하기 때문에 성능면에서 우수하다. 그래서 우리는 `IntersectionObserver` 를 사용해서 구현하기로 했다.

`IntersectionObserver` 는 아래와 값이 callback 함수와 옵션을 인자로 받는다.

```jsx
let observer = new IntersectionObserver(callback, options);
```

`callback`함수는 필수로 넣어야한다. target요소가 viewport에 교차되었을때 함수가 실행된다.
**options**는 아래와 같이 있다.

- **root**: 기본값은 null이다. null이면 전체 viewport로 잡는다. 아님 스크롤 컨테이너가 있다면 root를 스크롤 컨테이너로 잡는다.
- **rootMargin**: css의 margin과 비슷하다 px나 %로 줄 수 있다.
- **threshold**: 언제 교차되었을때 콜백함수를 실행시킬지 정할수 있다. 기본은 1이고 0~1까지 정하면 된다. 0.8이라하면 80%에 도달시 콜백함수를 실행하겠다라는 뜻이다.

이번 과제서는 콜백함수만 사용했고 옵션들을 따로 사용하지 않았다. 이유는 **root**는 전체 뷰이기 때문에 건들이지 안않고 역시 **rootMargin**도 설정할 필요가 없었고 **threshold**도 마찬가지로 100%로 내려왔을때 실행되기 바랬기 때문에 설정하지 않았다.

### 구현

`InfinityScroll` 기능을 구현하기전 간단하게 로직을 짜보았다. viewport 맨 아래쪽 자식요소에게 target을 설정하고 target이 부모요소와 교차가 된다면 콜백을 실행해서 다음 데이터가 보여진다.

페어분과 간단히 서로의 의견을 나눈뒤 열심히 구글링을 하게 되었다. 그러면서 어떻게 작성하는지 흐름을 파악하고 우리의 과제에 맞춰 코드를 작성하였다 `InfinityScroll` 컴포넌트를 따로 hooks라는 폴더에 분리에서 관리를 하였고 `InfinityScroll` 가 필요한 리스트 컴포넌트에 적용해서 사용하였다 그리고 중간중간에 이슈와 구글링으로 많이 배웠다. 보통 `try catch` 사용하지만 `finally` 는 처음 사용하였다. `finally` 는 `try catch` 관계없이 코드가 실행된다고 한다. 그리고 중간에 에러가 났었는데

![11](https://user-images.githubusercontent.com/60437099/127520777-0885b2dc-bb84-4837-af21-674e2b28e117.png)

이 오류는 함수가 호출 할 때 **destructuring assignment**를 시도하지만 아무런 값도 전달되지 않아서 생기는 오류라고 한다. 그래서 방법으로

```jsx
//before example
function (({ page }) //error

//after
function (({ page = {} }) //success
```

**destructuring assignment**를 할때 기본값으로 `{}` 를 지정해서 호출할때 인자를 주지 않아도 오류가 발생되지가 않다고 한다.

## 끝

이번 과제를 하면서 페어프로그래밍에 대한 장점을 많이 알아갔다. 혼자서는 놓치거나 알 수 없는 오류들을 페어분이 캐치해서 풀어나갔다 덕분에 재미있게 과제를 진행할수 있었다.
마지막으로 구현한 기능 영상이다.

![22](https://user-images.githubusercontent.com/60437099/127520835-dfd24180-7ce8-4ea3-806c-28e3a3e1b559.gif)
